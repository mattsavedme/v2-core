# Uni 为什么会在amountIn里收fee，而不是在amountOut
- 价格诚实，一开始就知道有一部分输入不参与兑换
- 数学更简单，不容易出bug,不需要先计算，再扣除，再修正的问题
- 换的越多，成本更明显，对池子更安全
- 规避输出很小时，无法收取到fee的极端情况
- 避免因为从amountOut扣除fee之后小于最小输出导致revert(猜测)

# uni v2的闪电贷
- swap函数里的data字段如果长度大于0，就认识是闪电贷
合约将调用to地址的uniswapV2Call函数，并传入data

# uni v2的oracle
- Uniswap V2 的 TWAP 不是存价格，而是累计 price × time
通过两次快照相减再除以时间，得到时间加权平均价格
这样可以用极低 gas 成本实现对闪电贷操纵高度不敏感的链上预言机。

- 使用的话获取两个时间节点的差值再除以时间差

# uni v2收协议收取的0.3%的1/6 的fee的形式是什么
- 在mint/burn时通过给feeTo地址mint Lp来稀释现有LP的份额

# uni v2 协议收取的1/6 fee是怎么计算的
- 最新K值与上一次分费时kLast的差值

# uni v3 ticker和price的关系
- price = 1.0001 ^ tick

# uni v3的bitMap有什么作用
- 快速找下一个 initialized tick,
从而在 swap 时能通过位运算快速定位下一个有效 tick，避免线性扫描

# uni v3 bitMap里的值什么时候会翻转
- 该区间第一次添加流动性
- 该区间的所有流动性被移除

# uni v3的oracle
- 

# 可升级合约的方式
- 透明代理
- UUPS

# 可升级合约的主要实现原理
- 基于delegatecall
- Delegatecall 是一种低级调用，在调用合约上下文执行目标合约代码，存储、msg.sender 和 msg.value 都保留原调用者

# 透明代理和UUPS的区别
- 区别在于升级的逻辑，透明代理的升级逻辑在代理合约，而UUPS的升级逻辑在实现合约

# __gap的本质
- 给未来升级预留的一段“storage 缓冲区”

# 内联汇编

# 内存空闲指针存在哪里
- 存在0x40的位置

# 空闲指针我用过了，如何找到下一个空闲指针的位置
- 通过**mstore、mload**和**add、sub**等函数来操作

# 内联汇编获取bytes数据的长度
- 内存地址指向 bytes 变量时，前 32 字节存的是数组长度，紧接着是数组实际内容
```solidity
function expternalCall(bytes data) external pure returns(uint len) {
    uint len;

    assembly {
        len := mload(data);
    }
}

function expternalCall(bytes calldata data) external pure returns(uint len) {
    uint len;

    assembly {
        len := calldataload(data.offset);
    }
}
```

# 可升级合约升级时如何在已有的slot中间插入新的slot
- 因为storage访问本质是基于slot, 所以只需要用自定义固定slot就可以杜绝覆盖的问题
- ssload 和 sstore可以直接指定slot，通过这种方式访问特定的slot
- 和EIP-1967类似
```solidity
bytes32 constant MY_SLOT = keccak256("my.unique.key");

function set(uint val) external {
    assembly { sstore(MY_SLOT, val) }
}

function get() external view returns(uint val) {
    assembly { val := sload(MY_SLOT) }
}
```

# EIP_1967
- EIP-1967 是一套“约定俗成的 storage slot 规范”，用来存 Proxy 自己的关键信息（implementation / admin / beacon），以避免与逻辑合约的 storage layout 冲突。

# EIP-712

# EIP-712如何验签
- 通过ecrecover恢复签名地址和签名人地址是否一致(r s v)
- r 代表椭圆上的x坐标，v指定选择哪个点，s是ECDSA 签名值，主要和r、消息哈希，确保签名和消息绑定

# nonce的理解
- 解决重放问题
- 防冲突
- 保证顺序(同一个地址的多笔交易)

# 函数选择器
- 选择器是 bytes4(keccak256("函数签名"))
- 如果函数选择器在合约里都没有匹配的函数，则
    + 如果 calldata 为空且 msg.value > 0，会执行 receive（前提是合约实现了 receive），否则 fallback 或 revert
	+ 如果 calldata 非空，会执行 fallback（前提是存在 fallback，否则 revert）
	+ 如果 calldata 为空且 msg.value = 0，会执行 fallback（前提是存在 fallback，否则 revert）

# ERC-721A做了哪些优化(Azuki)
- 批量Mint节省gas
- 使用 连续所有权记录减少写入的gas消耗

# 黑客攻击事件
- The DAO(促进check-effect-interaction)，导致以太坊硬分叉
- Axie Infinity(GameFi) 多签脆弱导致史上最大被盗案
- Curve(重入保护失效)
- bZx 闪电贷事件(数字溢出)
